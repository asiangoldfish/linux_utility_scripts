#!/usr/bin/env python

import json
import sys
import http.client
from pathlib import Path

class Request:
    def __init__(self) -> None:
        self.url = ""
        self.endpoint = ""
        self.method = ""
        self.headers = []
        self.data = object
        self.port = 0

    def unmarshall(self, json_obj) -> Bool:
        # TODO validate JSON fields
        self.url = json_obj.get("url")
        if self.url is None:
            print("Request is missing field 'url'")
            return False

        self.method = json_obj["method"]
        self.headers = json_obj.get("headers", {})
        self.endpoint = json_obj["endpoint"]
        self.port = json_obj["port"]

        # Keep in mind that data can be in different formats
        self.data = json_obj.get("data")

        if self.method not in ["GET", "POST", "PUT", "OPTION"]:
            print("Method \'" + self.method + "\' not supported")
            return False

        return True

    def send_request(self):
        print("Sending request..")
        connection = http.client.HTTPConnection(self.url, self.port)

        # Define headers and body
        headers = self.headers

        # Send the request
        connection.request(
                self.method, self.endpoint, json.dumps(self.data), self.headers)

        # Get the response
        response = connection.getresponse()

        # print(f"Status: {response.status} and reason: {response.reason}")

        # Read and decode the response
        content_length_str = response.getheader('Content-Length')
        if content_length_str is not None:
            content_length = int(content_length_str)
            if content_length > 0:
                data = response.read().decode('utf-8')
                print("Response:")
                # Response body can be JSON or plain text
                try:
                    json_response = json.loads(data)
                    print(json_response)
                except json.decoder.JSONDecodeError as e:
                    print(data)


def usage():
    print("""Usage: http-client.py <config-file> <request-name> OPTIONS

http-client.py is a simple, internal Python script for local development. It is
an HTTP client used to run HTTP tests or testing endpoints. You can store
project specific configuration files, so you don't need to clutter your one
and only HTTP client with requests from all your projects.

The script's goal is to provide an alternative to curl. Whereas you would
write the complete request directly in your terminal, you now specify the
request meta data in a file.

Optional arguments:
  -g, --generate-config         generate a configuration template
""", end='')

def generate_config():
    config_path = Path("http.json")

    if config_path.is_file():
        print("http.json already exists")
        return

    template = [
        {
            "request_name": {
                "url": "localhost",
                "port": 8080,
                "endpoint": "/health",
                "method": "POST",
                "headers": {
                    "Content-Type": "application/json"
                },
                "data": ""
            }
        }
    ]

    with open("http.json", "w") as fp:
        json.dump(template, fp, indent=4)

# Default: help page
if len(sys.argv) <= 1:
    usage()
    exit(0)

# Check for arguments
for arg in sys.argv:
    if arg in ["-g", "--generate-config"]:
        generate_config()
        exit(0)

# Assume user wants to run the HTTP client.
if len(sys.argv) != 3:
    print("Missing arguments: <config-file> and <request-name>")
    exit(0)

FILE_NAME = sys.argv[1]
REQUEST_NAME = sys.argv[2]

request_object = {}

# Register the JSON object
with open(FILE_NAME) as f:
    json_file = json.load(f)
    request_object = json_file

# We require the top level to be a list
if type(request_object) is not list:
    print("Top level must be an array", file=sys.stderr)
    exit(1)

# Check if any requests exist
if len(request_object) == 0:
    print("No requests found in " + FILE_NAME, file=sys.stderr)
    exit(1)

req = Request()
exit_code = False
for req_obj in request_object:
    if req_obj.get(REQUEST_NAME):
        exit_code = req.unmarshall(req_obj.get(REQUEST_NAME))
        break


if exit_code is False:
    exit(1)

req.send_request()
